# Matrix Reconstruction

## Matrix Reconstruction - Writeup

### Challenge Information

* **Category**: Cryptography
* **Points**: Medium/Hard
* **Author**: DJ Strigel
* **Description**: Someone's been messing with your secure communication channel… and they've left traces! You've intercepted a mysterious ciphertext and a series of leaked internal states from a rogue pseudorandom generator. It seems the generator is powered by a secret 32×32 matrix A and an unknown 32-bit vector B. Your mission: reverse-engineer the system! Use the leaked states to reconstruct the hidden matrix, uncover the XOR constant, and decrypt the message.

### Files Provided

* `cipher.txt` - Encrypted message (35 bytes)
* `keystream_leak.txt` - 40 leaked internal PRNG states
* `README.txt` - Model specification

### Solution

#### Challenge Overview

This challenge involves **Linear Feedback Shift Register (LFSR) cryptanalysis** over GF(2) (Galois Field with 2 elements). We must:

1. Recover a secret 32×32 binary matrix **A**
2. Recover a 32-bit XOR constant vector **B**
3. Use these to regenerate the keystream
4. Decrypt the ciphertext

#### Mathematical Model

The PRNG follows this recurrence relation:

```
S[n+1] = A × S[n] ⊕ B
```

Where:

* **A**: 32×32 binary matrix (all elements in {0, 1})
* **S\[n]**: 32-bit state at step n (represented as bit vector)
* **B**: 32-bit constant vector
* **×**: Matrix-vector multiplication over GF(2) (AND for multiplication, XOR for addition)
* **⊕**: Bitwise XOR

The keystream is generated by taking the **lowest byte** (bits 0-7) of each state.

#### Step 1: Problem Formulation

Given 40 consecutive states S\[0], S\[1], ..., S\[39], we have 39 transitions:

```
S[1] = A × S[0] ⊕ B
S[2] = A × S[1] ⊕ B
...
S[39] = A × S[38] ⊕ B
```

Each transition gives us **32 equations** (one per bit position), so:

* **Total equations**: 39 transitions × 32 bits = 1,248 equations
* **Total unknowns**: 32×32 (matrix A) + 32 (vector B) = 1,056 unknowns

Since we have **more equations than unknowns** (overdetermined system), we can solve using **Gaussian elimination over GF(2)**.

#### Step 2: Converting to Linear System

For the j-th bit of state S\[i+1]:

```
S[i+1][j] = (A[j,:] · S[i]) ⊕ B[j]
```

Where:

* `A[j,:]` is the j-th row of matrix A
* `·` is dot product over GF(2)

Expanding this equation:

```
S[i+1][j] = (A[j,0]×S[i][0] ⊕ A[j,1]×S[i][1] ⊕ ... ⊕ A[j,31]×S[i][31]) ⊕ B[j]
```

This is a **linear equation over GF(2)** in the unknowns `A[j,0], A[j,1], ..., A[j,31], B[j]`.

#### Step 3: System Construction

We construct augmented matrix `[M | V]` where:

* **M**: Coefficient matrix (1248 × 1056)
* **V**: Result vector (1248 × 1)

For each transition i→i+1 and bit position j:

* **Equation index**: `eq_idx = i × 32 + j`
* **Coefficients for A\[j,k]**: `M[eq_idx, j×32 + k] = S[i][k]`
* **Coefficient for B\[j]**: `M[eq_idx, 1024 + j] = 1`
* **Result**: `V[eq_idx] = S[i+1][j]`

#### Step 4: Gaussian Elimination Over GF(2)

Standard Gaussian elimination with modifications:

1. **Addition becomes XOR**: `a + b ≡ a ⊕ b`
2. **Multiplication is AND**: `a × b ≡ a ∧ b`
3. **Division is identity**: In GF(2), the only non-zero element (1) is its own inverse

**Algorithm**:

```
For each column (pivot):
    1. Find a row with 1 in pivot position
    2. Swap to make it the pivot row
    3. For all other rows with 1 in this column:
        XOR them with the pivot row
```

#### Step 5: Back Substitution

After row echelon form, extract solution by back substitution:

* Each row with a leading 1 gives one variable's value
* Substitute known values into earlier equations
* All arithmetic is XOR-based

#### Complete Solver Implementation

```python
#!/usr/bin/env python3
import numpy as np

def int_to_bits(n, width=32):
    """Convert integer to bit array (LSB first)"""
    return [(n >> i) & 1 for i in range(width)]

def bits_to_int(bits):
    """Convert bit array to integer"""
    return sum(b << i for i, b in enumerate(bits))

def read_states():
    with open('files/keystream_leak.txt', 'r') as f:
        return [int(line.strip()) for line in f]

def read_cipher():
    with open('files/cipher.txt', 'rb') as f:
        return f.read()

def solve_lfsr(states):
    n_states = len(states)
    n_bits = 32
    
    state_bits = [int_to_bits(s, n_bits) for s in states]
    
    # Build system: M*x = V over GF(2)
    n_unknowns = n_bits * n_bits + n_bits  # 1056
    n_equations = (n_states - 1) * n_bits  # 1248
    
    M = np.zeros((n_equations, n_unknowns), dtype=np.uint8)
    V = np.zeros(n_equations, dtype=np.uint8)
    
    eq_idx = 0
    for i in range(n_states - 1):
        s_curr = state_bits[i]
        s_next = state_bits[i + 1]
        
        for j in range(n_bits):
            # Coefficients for A[j,:]
            for k in range(n_bits):
                M[eq_idx, j * n_bits + k] = s_curr[k]
            # Coefficient for B[j]
            M[eq_idx, n_bits * n_bits + j] = 1
            # Result
            V[eq_idx] = s_next[j]
            eq_idx += 1
    
    # Solve using Gaussian elimination
    augmented = np.hstack([M, V.reshape(-1, 1)])
    solution = gauss_gf2(augmented, n_unknowns)
    
    # Extract A and B
    A = np.zeros((n_bits, n_bits), dtype=np.uint8)
    for j in range(n_bits):
        for k in range(n_bits):
            A[j, k] = solution[j * n_bits + k]
    
    B = solution[n_bits * n_bits : n_bits * n_bits + n_bits]
    
    return A, B

def gauss_gf2(augmented, n_vars):
    """Gaussian elimination over GF(2)"""
    aug = augmented.copy()
    rows, cols = aug.shape
    
    pivot_row = 0
    for col in range(n_vars):
        # Find pivot
        found = False
        for row in range(pivot_row, rows):
            if aug[row, col] == 1:
                aug[[pivot_row, row]] = aug[[row, pivot_row]]
                found = True
                break
        
        if not found:
            continue
        
        # Eliminate
        for row in range(rows):
            if row != pivot_row and aug[row, col] == 1:
                aug[row] ^= aug[pivot_row]
        
        pivot_row += 1
    
    # Back substitution
    solution = np.zeros(n_vars, dtype=np.uint8)
    
    for row in range(min(pivot_row, rows) - 1, -1, -1):
        leading_col = -1
        for col in range(n_vars):
            if aug[row, col] == 1:
                leading_col = col
                break
        
        if leading_col == -1:
            continue
        
        val = aug[row, -1]
        for col in range(leading_col + 1, n_vars):
            val ^= solution[col] & aug[row, col]
        
        solution[leading_col] = val
    
    return solution

def generate_keystream(A, B, initial_state, length):
    """Generate keystream from PRNG"""
    n_bits = 32
    state = np.array(int_to_bits(initial_state, n_bits), dtype=np.uint8)
    keystream = []
    
    for _ in range(length):
        # Extract lowest byte
        keystream.append(bits_to_int(state[:8]))
        # Next state: A*state XOR B
        state = (A @ state) % 2
        state ^= B
    
    return bytes(keystream)

def main():
    states = read_states()
    cipher = read_cipher()
    
    # Solve for A and B
    A, B = solve_lfsr(states)
    
    # Generate keystream
    keystream = generate_keystream(A, B, states[0], len(cipher))
    
    # Decrypt
    plaintext = bytes(c ^ k for c, k in zip(cipher, keystream))
    print(plaintext.decode())

if __name__ == "__main__":
    main()
```

#### Execution

```bash
python3 solver.py
```

**Output**:

```
============================================================
Matrix Reconstruction LFSR Solver
============================================================

[*] Ciphertext length: 35 bytes
[*] Loaded 40 states
[*] Building system of linear equations over GF(2)...
[*] System: 1248 equations, 1056 unknowns
[*] Solving using Gaussian elimination over GF(2)...
[+] Solution found!

[*] Verifying solution...
[+] Verification successful!

[*] Generating keystream of length 35...

============================================================
DECRYPTED MESSAGE:
============================================================
pctf{mAtr1x_r3construct?on_!s_fu4n}
============================================================
```

#### Solution Analysis

**Recovered Parameters**:

* **Matrix A**: 32×32 binary matrix (specific values recovered by solver)
* **Vector B**: `[0, 0, 0, ..., 0]` (all zeros!)

**Key Insight**: The XOR constant B turned out to be zero, simplifying the recurrence to:

```
S[n+1] = A × S[n]
```

This is a **pure linear LFSR** without the XOR offset.

#### Verification Process

1. **State sequence check**: Verify that `A × S[i] ⊕ B = S[i+1]` for all transitions
2. **Keystream generation**: Generate 35 bytes from initial state S\[0]
3. **Decryption**: XOR ciphertext with keystream
4. **Flag validation**: Check for valid flag format

All checks passed ✓

### Key Insights

#### Why This Attack Works

1. **Linear Algebra Over GF(2)**
   * LFSR operations are linear over GF(2)
   * Linearity enables solving via Gaussian elimination
   * No nonlinear components to complicate analysis
2. **Overdetermined System**
   * 1,248 equations vs 1,056 unknowns
   * Redundancy ensures unique solution
   * Extra equations provide verification
3. **State Leakage**
   * Full internal states exposed (not just output)
   * Complete knowledge of state transitions
   * No truncation or output filtering
4. **Known Plaintext Not Required**
   * Attack uses **known consecutive states**, not plaintext
   * Pure structural attack on PRNG itself
   * Ciphertext only needed for final decryption

#### Security Analysis

**Why This PRNG Is Broken**:

* ✗ **State exposure**: Internal states leaked
* ✗ **Linear structure**: Over GF(2) allows algebraic attacks
* ✗ **No nonlinearity**: No S-boxes or modular addition
* ✗ **Predictable**: Given states, future/past outputs computable

**Secure PRNG Requirements**:

* ✓ **Nonlinear transformations** (S-boxes, modular ops)
* ✓ **State protection** (never expose internal state)
* ✓ **Large state space** (resist brute force)
* ✓ **Cryptographic primitives** (AES-CTR, ChaCha20)

#### Real-World Analogues

This attack is similar to:

1. **Berlekamp-Massey Algorithm**: Solves for LFSR from output sequence
2. **LFSR Cryptanalysis**: Classic attack on stream ciphers like A5/1 (GSM)
3. **Algebraic Attacks**: Solving cipher equations as linear systems

### Mathematical Deep Dive

#### GF(2) Arithmetic

Galois Field with 2 elements: {0, 1}

**Addition** (XOR):

```
0 ⊕ 0 = 0
0 ⊕ 1 = 1
1 ⊕ 0 = 1
1 ⊕ 1 = 0
```

**Multiplication** (AND):

```
0 × 0 = 0
0 × 1 = 0
1 × 0 = 0
1 × 1 = 1
```

**Properties**:

* Additive identity: 0
* Multiplicative identity: 1
* Every element is its own additive inverse: `a ⊕ a = 0`
* No subtraction needed: subtraction = addition

#### Matrix Multiplication Over GF(2)

For `C = A × B`:

```
C[i,j] = Σ(A[i,k] × B[k,j])  (sum is XOR, product is AND)
```

**Example**: 2×2 matrix × 2-bit vector

```
[1 0] × [1]  =  [1×1 ⊕ 0×0]  =  [1]
[1 1]   [0]     [1×1 ⊕ 1×0]     [1]
```

#### System Complexity

* **Gaussian elimination complexity**: O(n³) where n = 1056
* **Operations**: \~1,056³ ≈ 1.2 billion bit operations
* **Practical runtime**: < 1 second on modern CPU

### Common Pitfalls

1. **Bit ordering**: LSB vs MSB (challenge uses LSB-first)
2. **Modular arithmetic**: Must use `% 2` for GF(2), not regular mod
3. **Matrix indexing**: Row-major vs column-major storage
4. **Keystream extraction**: Must take **lowest byte** of each state
5. **XOR vs addition**: In GF(2) they're the same, but implementation differs

### Tools Used

* Python 3 with NumPy - Matrix operations and solving
* GF(2) arithmetic - Custom implementation

### Timeline

* Understanding LFSR model: 15 minutes
* Setting up linear system: 20 minutes
* Implementing Gaussian elimination: 25 minutes
* Debugging and verification: 15 minutes
* Final decryption: 5 minutes
* **Total**: \~80 minutes

### Flag

```
pctf{mAtr1x_r3construct?on_!s_fu4n}
```

### Learning Outcomes

This challenge teaches:

1. **Linear cryptanalysis**: Exploiting linear structures in cryptographic systems
2. **GF(2) algebra**: Working with binary fields
3. **LFSR internals**: Understanding linear feedback shift registers
4. **Gaussian elimination**: Solving large linear systems
5. **State recovery attacks**: Reconstructing PRNG parameters from observations
6. **Matrix reconstruction**: Determining unknown transformations from input-output pairs

### References

* Linear Feedback Shift Registers: https://en.wikipedia.org/wiki/Linear-feedback\_shift\_register
* Galois Field GF(2): https://en.wikipedia.org/wiki/GF(2)
* Berlekamp-Massey Algorithm: https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey\_algorithm
* Stream Cipher Cryptanalysis: https://en.wikipedia.org/wiki/Stream\_cipher\_attacks
* Gaussian Elimination: https://en.wikipedia.org/wiki/Gaussian\_elimination

### Additional Notes

#### Why 40 States?

Minimum states needed:

```
Unknowns = 32² + 32 = 1056
Equations per transition = 32
Minimum transitions = ⌈1056/32⌉ = 33
Minimum states = 33 + 1 = 34
```

Challenge provides **40 states** (39 transitions = 1248 equations), giving us **192 extra equations** for robustness and verification.

#### Alternative Approaches

1. **Sage/SymPy**: Use symbolic math libraries with built-in GF(2) support
2. **Z3 Solver**: Model as SAT problem and use SMT solver
3. **Linear algebra libraries**: Use specialized GF(2) linear algebra packages

#### Extension Ideas

For harder variant:

* Truncate output (only give partial bits of each state)
* Use larger field (GF(2^n))
* Add nonlinear components
* Introduce state-dependent matrix (non-constant A)
