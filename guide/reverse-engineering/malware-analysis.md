---
icon: mosquito-net
---

# Malware Analysis

## **Malware Reverse Engineering ‚Äî The Art of Unpacking the Beast**

***

Malware reverse engineering (MRE) is the **forensic dissection of malicious binaries** to uncover what they do, how they do it, and how to stop (or repurpose) them.\
From ransomware unpacking to APT loader tracing, this is where **binary analysis meets threat intelligence**.

This guide covers static and dynamic analysis, behavior mapping, anti-analysis evasion, and memory forensics ‚Äî built for both **CTF reverse challenges** and **real-world malware teardown**.

***

### I. üß© Core Malware Concepts

| Concept                    | Description                                                        |
| -------------------------- | ------------------------------------------------------------------ |
| **Dropper**                | Initial loader delivering payloads.                                |
| **Payload**                | Actual malicious code (stealer, RAT, ransomware).                  |
| **Persistence**            | Mechanisms ensuring malware re-executes after reboot.              |
| **C2 (Command & Control)** | Remote infrastructure controlling malware.                         |
| **Packing / Obfuscation**  | Techniques hiding or encrypting code.                              |
| **Injection**              | Injecting payloads into legitimate processes (e.g., explorer.exe). |
| **Sandbox Evasion**        | Detecting or escaping automated analysis.                          |

***

### II. ‚öôÔ∏è Analysis Environment Setup

üß† **Golden Rule:** Never analyze on your main OS.

#### ‚öôÔ∏è 1. Safe VM Setup

* Host OS: Linux or Windows with isolation.
* VM: Windows 10/11 + Snapshots.
* Disable networking, or use **INetSim** for fake internet simulation.

#### ‚öôÔ∏è 2. Essential Tools

| Category        | Tools                                            |
| --------------- | ------------------------------------------------ |
| Static          | Ghidra, IDA, DIE, PEiD                           |
| Dynamic         | x64dbg, Process Monitor, Procmon, Process Hacker |
| Memory          | Volatility3, Rekall                              |
| Network         | Wireshark, Fakenet-NG, INetSim                   |
| Strings/Entropy | FLOSS, binwalk, Detect-It-Easy                   |
| Behavior        | Any.Run, CAPEv2, Cuckoo Sandbox                  |

***

### III. ‚öôÔ∏è Static Analysis ‚Äî Pre-Execution Dissection

#### üß† 1. Identify File Type

```bash
file sample.exe
pefile sample.exe
```

Check if PE, ELF, or Mach-O.

#### ‚öôÔ∏è 2. Check Packing / Encryption

```bash
Detect-It-Easy sample.exe
```

or

```bash
upx -t sample.exe
```

If UPX packed:

```bash
upx -d sample.exe
```

#### üß© 3. Extract Strings

```bash
floss sample.exe > strings.txt
grep -E "http|cmd|powershell|key|flag" strings.txt
```

***

#### ‚öôÔ∏è 4. Check Imports / APIs

```bash
peframe sample.exe
```

or manually:

```bash
objdump -p sample.exe | grep -i import
```

Look for suspicious APIs:

```
CreateRemoteThread
VirtualAllocEx
InternetConnect
WriteProcessMemory
```

***

#### üß† 5. Analyze Sections

```bash
readelf -S malware
```

Suspicious indicators:

* Unusual entropy in `.text`
* Code in `.data` or `.rdata`
* Overwritten headers

***

#### ‚öôÔ∏è 6. Use Ghidra / IDA

Follow logic flow:

* `WinMain()`, `_start`, or `main()`
* API imports: `LoadLibraryA`, `GetProcAddress`
* Hardcoded strings: URLs, registry keys, file paths
* Look for decryption or unpacking routines (loops or XORs)

***

### IV. ‚öôÔ∏è Dynamic Analysis ‚Äî Behavior in Action

#### üß© 1. Run Under Monitor

```bash
procmon.exe
```

Track:

* File system modifications
* Registry writes
* Process creation
* Network connections

#### ‚öôÔ∏è 2. Check Network Behavior

```bash
fakenet-ng
wireshark
```

Monitor:

* HTTP POST to unknown IPs
* DNS requests to suspicious domains
* Encrypted outbound traffic

***

#### üß† 3. API Call Tracing

```bash
API Monitor
Process Hacker
x64dbg
```

Watch for:

* `CreateProcess` (spawning payload)
* `RegSetValueEx` (persistence)
* `OpenProcess` + `WriteProcessMemory` (injection)

***

#### ‚öôÔ∏è 4. Debug Step-by-Step

```bash
x64dbg sample.exe
```

Breakpoints:

* `CreateProcessA`
* `WinExec`
* `InternetConnect`
* `WriteFile`

Step through to watch decryption and unpacking routines.

***

### V. üí£ Unpacking Malware

#### üß© 1. Detect the Packer

* UPX ‚Üí simple unpack
* Themida / VMProtect ‚Üí advanced
* Custom XOR ‚Üí manual reversing

#### ‚öôÔ∏è 2. Dump Unpacked Memory

```bash
x64dbg ‚Üí Dump memory ‚Üí Rebuild PE with Scylla
```

#### üí£ 3. Automate with UnpacMe / CAPE

Upload ‚Üí auto-unpack ‚Üí retrieve clean binary.

***

### VI. ‚öôÔ∏è Malware Behavior Mapping

#### üß† 1. File System Indicators

* `%AppData%\Microsoft\Windows\Start Menu\Programs\Startup\`
* `%TEMP%\random.exe`
* `C:\Users\<user>\AppData\Roaming\`

#### ‚öôÔ∏è 2. Registry Persistence

```powershell
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run
```

#### üß© 3. Scheduled Tasks

```powershell
schtasks /query /fo LIST /v
```

***

### VII. ‚öôÔ∏è Code Injection & Process Hollowing

| Technique              | Description                            | API Indicators                                            |
| ---------------------- | -------------------------------------- | --------------------------------------------------------- |
| **Classic Injection**  | Inject shellcode into remote process   | `OpenProcess`, `WriteProcessMemory`, `CreateRemoteThread` |
| **Process Hollowing**  | Replace memory of a legitimate process | `NtUnmapViewOfSection`, `ZwWriteVirtualMemory`            |
| **Reflective Loading** | Load DLL from memory                   | `LoadLibrary`, `VirtualAlloc`                             |
| **APC Injection**      | Queue APCs in target thread            | `QueueUserAPC`                                            |

Use `x64dbg` or `Procmon` to visualize injected threads and memory regions.

***

### VIII. üß† Network & C2 Analysis

#### ‚öôÔ∏è 1. Capture Communication

```bash
wireshark -i 1 -f "tcp port 80 or 443"
```

Look for:

* POST requests with encoded data
* Domains resembling legit names (e.g. `micros0ft-update.net`)

#### ‚öôÔ∏è 2. Fake C2 Interaction

Use **INetSim** to simulate network services:

```bash
inetsim --service http --service dns
```

Observe malware‚Äôs connection attempts.

***

### IX. ‚öôÔ∏è Memory Forensics

#### üß† 1. Capture RAM

```bash
winpmem.exe --output mem.raw
```

#### ‚öôÔ∏è 2. Analyze with Volatility

```bash
volatility3 -f mem.raw windows.pslist
volatility3 -f mem.raw windows.malfind
volatility3 -f mem.raw windows.cmdline
```

Use `malfind` to detect injected code and hidden modules.

***

### X. ‚öôÔ∏è Deobfuscation & Decryption

#### üß† 1. Identify XOR / RC4 Loops

Look for patterns like:

```asm
xor eax, 0x13
add edi, 1
```

or

```c
for (i=0;i<len;i++) buf[i]^=key;
```

#### ‚öôÔ∏è 2. Recreate Algorithm

Use Python to decrypt:

```python
data = [0x45, 0x47, 0x50]
key = 0x13
print(''.join([chr(b ^ key) for b in data]))
```

#### üí£ 3. Dynamic Dump Decrypted Data

Hook memory using:

```bash
frida-trace -i "VirtualAlloc" -i "WriteFile" sample.exe
```

***

### XI. ‚öôÔ∏è Common Malware Techniques

| Technique                    | Description                                 |
| ---------------------------- | ------------------------------------------- |
| **Process Hollowing**        | Inject payload into legitimate process      |
| **Persistence via Registry** | Run malware on boot                         |
| **Keylogging**               | Capture keystrokes via `GetAsyncKeyState`   |
| **Credential Dumping**       | Access `lsass.exe` memory                   |
| **Screen Capture**           | Using `BitBlt` and `CreateCompatibleBitmap` |
| **Exfiltration**             | Sending stolen data via HTTP/DNS            |
| **C2 Obfuscation**           | Encrypting communications (base64, XOR)     |

***

### XII. ‚öôÔ∏è Evasion & Anti-Analysis Tricks

| Behavior               | Indicator                                    | Bypass                    |
| ---------------------- | -------------------------------------------- | ------------------------- |
| **Anti-VM**            | Checks for VMware registry keys              | Patch or emulate registry |
| **Anti-Debug**         | Calls to `IsDebuggerPresent`                 | Patch to return false     |
| **Sleep Delays**       | Long `Sleep()` calls                         | Hook and skip             |
| **Environment Checks** | Looking for process names like `procmon.exe` | Rename tools              |
| **Encrypted APIs**     | Dynamic import resolution                    | Break at `LoadLibraryA`   |

***

### XIII. ‚öôÔ∏è Behavioral Sandboxing

#### üß† 1. CAPEv2 Sandbox

Automatically:

* Unpacks
* Monitors API calls
* Generates YARA signatures
* Produces network PCAPs

#### ‚öôÔ∏è 2. Any.Run (Interactive)

Upload sample ‚Üí run ‚Üí interact ‚Üí export behavior trace.

***

### XIV. ‚öôÔ∏è YARA & Signature Creation

Create custom detection rules:

```yara
rule EvilMalware {
    strings:
        $s1 = "VirtualAllocEx"
        $s2 = "cmd.exe /c"
        $s3 = "POST /data"
    condition:
        all of them
}
```

Scan:

```bash
yara -r EvilMalware.yar samples/
```

***

### XV. ‚öôÔ∏è Incident Response Integration

| Artifact      | Description                 |
| ------------- | --------------------------- |
| Memory Dump   | Extract injected payloads   |
| Disk Image    | Locate persistence          |
| PCAP          | Analyze exfiltration        |
| Registry Hive | Startup entries             |
| Logs          | Process creation timestamps |

Integrate with ELK/Splunk or MISP for threat intel correlation.

***

### XVI. ‚öîÔ∏è Pro Tips & Operator Tricks

‚úÖ **Run in Layers:**\
Start static ‚Üí trace behavior ‚Üí dump memory ‚Üí rebuild PE ‚Üí analyze logic.

‚úÖ **Snapshots Are Life:**\
Revert VM after each execution to reset artifacts.

‚úÖ **Frida = Power:**\
Hook live API calls to dump decrypted payloads mid-runtime.

‚úÖ **Network Sim = Gold:**\
Fake all internet services with INetSim ‚Äî you‚Äôll see what domains it tries to reach.

‚úÖ **Look for Sleep Skips:**\
Replace `Sleep(600000)` with `Sleep(0)` to save time.

‚úÖ **Automate Your Analysis:**\
Use CAPEv2 to generate reports + YARA rules automatically.

‚úÖ **Check For Hidden DLLs:**\
Injected or reflective DLLs won‚Äôt show up in imports ‚Äî check `malfind`.

***

### XVII. ‚öôÔ∏è Quick Reference Table

| Goal             | Tool / Command                  | Description                   |
| ---------------- | ------------------------------- | ----------------------------- |
| Identify Malware | `Detect-It-Easy`                | Detect packers, compiler      |
| Extract Strings  | `floss sample.exe`              | Decode obfuscated strings     |
| Monitor Behavior | `procmon`, `fakenet-ng`         | File/network trace            |
| Disassemble      | `ghidra`, `ida`                 | Inspect logic flow            |
| Dump Memory      | `x64dbg` + Scylla               | Dump unpacked code            |
| Analyze RAM      | `volatility3`                   | Extract hidden processes      |
| Detect C2        | `wireshark`                     | Inspect network traffic       |
| Sandbox          | `cape`, `any.run`               | Automated behavioral analysis |
| Create YARA      | `yara EvilMalware.yar samples/` | Detection rule matching       |

***
