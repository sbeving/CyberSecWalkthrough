# Entropy Discord

## Entropy Discord - Reverse Engineering Challenge

### Challenge Overview

* **Category**: Reverse Engineering / Crypto
* **Difficulty**: Medium
* **Flag Format**: `PCTF{...}`

### Description

A challenge involving reverse engineering a pseudorandom number generator (PRNG) based encryption scheme.

### Solution

#### Initial Analysis

The challenge provided encrypted data that was XORed with a keystream generated by a custom PRNG (Permuted Congruential Generator).

#### Key Observations

1. **PRNG Implementation**
   * Uses a 64-bit seed
   * Linear Congruential Generator (LCG) formula: `state = (state * multiplier + increment) % modulus`
   * Output is permuted/transformed before being used as keystream
2. **Known Plaintext**
   * Flag format is known: `PCTF{...}`
   * First 5 bytes are fixed: `PCTF{`
   * This gives us the first 5 bytes of the keystream
3. **Vulnerability**
   * The PRNG seed can be brute-forced using the known plaintext
   * With the keystream bytes recovered from `PCTF{`, we can search for matching seeds

#### Attack Strategy

1.  **Extract Keystream from Known Plaintext**

    ```python
    # XOR encrypted data with known plaintext to get keystream
    known_plain = b'PCTF{'
    keystream = [enc[i] ^ known_plain[i] for i in range(5)]
    # Result: [99, 196, 92, 254, 217] (0x63c45cfed9)
    ```
2.  **Brute Force Seed**

    ```python
    # Try all possible seeds and check if they generate matching keystream
    for seed in range(0, 2**64):
        prng = CustomPRNG(seed)
        test_keystream = [prng.next() for _ in range(5)]
        if test_keystream == keystream:
            found_seed = seed
            break
    ```
3.  **Decrypt Full Message**

    ```python
    # Once seed is found, generate full keystream and decrypt
    prng = CustomPRNG(found_seed)
    decrypted = bytes([enc[i] ^ prng.next() for i in range(len(enc))])
    ```

#### Solution Script

```python
def solve():
    encrypted_data = [...]  # From challenge
    
    # Known plaintext attack
    known = b'PCTF{'
    keystream = [encrypted_data[i] ^ known[i] for i in range(5)]
    
    # Brute force seed
    for seed in range(2**64):
        if seed % 1000000 == 0:
            print(f"Tried {seed} seeds...")
        
        prng = CustomPRNG(seed)
        test = [prng.next() for _ in range(5)]
        
        if test == keystream:
            print(f"[SUCCESS] Found matching seed: {hex(seed)}")
            
            # Decrypt with found seed
            prng = CustomPRNG(seed)
            flag = bytes([encrypted_data[i] ^ prng.next() 
                         for i in range(len(encrypted_data))])
            
            print(f"[*] Decrypted flag: {flag}")
            return flag
```

#### Execution Results

```
[*] Trying to reverse-engineer seed from common flag patterns...
[*] Brute forcing seed (this may take a moment)...
    Tried 0 seeds...

[SUCCESS] Found matching seed: 0x434b59bd41562279
[*] Decrypted flag: b'PCTF{iTz_mY_puT3R--My_3nT40PY}'
```

### Flag

```
PCTF{iTz_mY_puT3R--My_3nT40PY}
```

### Key Takeaways

1. **Known Plaintext Attack**: Flag formats provide known plaintext for cryptanalysis
2. **PRNG Weaknesses**: Custom PRNGs with small state space are vulnerable to brute force
3. **XOR Encryption**: When keystream is predictable/recoverable, XOR encryption is completely broken
4. **Seed Recovery**: With enough known plaintext, PRNG seeds can be reverse-engineered

### Tools Used

* Python 3
* Custom PRNG implementation analysis
* Brute force search

### References

* Linear Congruential Generator (LCG)
* Permuted Congruential Generator (PCG)
* Known Plaintext Attack
* XOR cipher cryptanalysis

***
